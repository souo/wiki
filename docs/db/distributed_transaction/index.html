<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-db/distributed_transaction">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.1">
<link rel="alternate" type="application/rss+xml" href="/wiki/blog/rss.xml" title="Dev Wiki RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/wiki/blog/atom.xml" title="Dev Wiki Atom Feed">




<link rel="stylesheet" href="/wiki/katex/katex.min.css"><title data-rh="true">分布式事务 | Dev Wiki</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="http://souo.github.io/wiki/docs/db/distributed_transaction"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="分布式事务 | Dev Wiki"><meta data-rh="true" name="description" content="在单个数据库的情况下，数据事务操作具有 ACID 四个特性，但如果在一个事务中操作多个数据库，则无法使用数据库事务来保证一致性。"><meta data-rh="true" property="og:description" content="在单个数据库的情况下，数据事务操作具有 ACID 四个特性，但如果在一个事务中操作多个数据库，则无法使用数据库事务来保证一致性。"><link data-rh="true" rel="canonical" href="http://souo.github.io/wiki/docs/db/distributed_transaction"><link data-rh="true" rel="alternate" href="http://souo.github.io/wiki/docs/db/distributed_transaction" hreflang="en"><link data-rh="true" rel="alternate" href="http://souo.github.io/wiki/docs/db/distributed_transaction" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://undefined-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/wiki/assets/css/styles.a6de386b.css">
<link rel="preload" href="/wiki/assets/js/runtime~main.4af80907.js" as="script">
<link rel="preload" href="/wiki/assets/js/main.6f5d8ae1.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/wiki/"><b class="navbar__title text--truncate">知识库</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/wiki/get-started">Get Started</a><a class="navbar__item navbar__link" href="/wiki/docs/welcome">Docs</a><a class="navbar__item navbar__link" href="/wiki/blog">Blog</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">WIKI</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/wiki/docs/java/jvm/jvm-architecture">Java</a></li><li><a class="dropdown__link" href="/wiki/docs/bigdata/hbase/hbase-architecture">BigData</a></li><li><a class="dropdown__link" href="/wiki/docs/math/quick-power">math</a></li><li><a class="dropdown__link" href="/wiki/docs/db/profiling/sql">数据库</a></li><li><a class="dropdown__link" href="/wiki/docs/questions/java/class_file">面试题</a></li></ul></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><main class="docMainContainer_gTbr docMainContainerEnhanced_Uz_u"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>分布式事务</h1></header><p>在单个数据库的情况下，数据事务操作具有 ACID 四个特性，但如果在一个事务中操作多个数据库，则无法使用数据库事务来保证一致性。</p><p>分布式事务就是为了解决在同一个事务下，不同节点的数据库操作数据不一致的问题。在一个事务操作请求多个服务或多个数据库节点时，要么所有请求成功，要么所有请求都失败回滚回去。通常，分布式事务的实现有多种方式，例如 XA 协议实现的二阶提交（2PC）、三阶提交 (3PC)，以及 TCC 补偿性事务。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="xa-规范">XA 规范<a class="hash-link" href="#xa-规范" title="Direct link to heading">​</a></h2><p>在 XA 规范之前，存在着一个 DTP 模型，该模型规范了分布式事务的模型设计。</p><p>DTP 规范中主要包含了 AP、RM、TM 三个部分，其中 AP 是应用程序，是事务发起和结束的地方；RM 是资源管理器，主要负责管理每个数据库的连接数据源；TM 是事务管理器，负责事务的全局管理，包括事务的生命周期管理和资源的分配协调等。</p><p><img loading="lazy" src="/wiki/assets/images/dtp-898659c4a93adc488bba4f3cdb2039af.webp" width="1086" height="676" class="img_ev3q">
XA 则规范了 TM 与 RM 之间的通信接口，在 TM 与多个 RM 之间形成一个双向通信桥梁，从而在多个数据库资源下保证 ACID 四个特性。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2pc">2PC<a class="hash-link" href="#2pc" title="Direct link to heading">​</a></h3><p>第一阶段，应用程序向事务管理器（TM）发起事务请求，而事务管理器分别向参与的各个资源管理器 (RM) 发送事务预处理请求（Prepare）。此时这些资源管理器会打开本地数据库事务，然后开始执行数据库事务,但执行完成后并不会立即提交事务，而是向事务管理器返回已就绪（Ready）或未就绪（Not Ready）状态。如果各个参与节点都返回状态了，就会进入第二阶段。
<img loading="lazy" src="/wiki/assets/images/2PC1-d02ed8d186a5769b6da77c016ae8286e.webp" width="2224" height="746" class="img_ev3q"></p><p>到了第二阶段，如果各个资源管理器返回的都是就绪状态，事务管理器则会向各个资源管理器发送提交（commit)通知。资源管理器则会完成本地数据库的事务提交，最终返回提交结果给事务管理器。
<img loading="lazy" src="/wiki/assets/images/2PC2-587af8e6f7e38e8d9bc4ad9490f9cba0.webp" width="2212" height="688" class="img_ev3q"></p><p>在第二阶段中，如果任意资源管理器返回了未就绪状态，此时事务管理器会向所有资源管理器发送事务回滚（Rollback）通知，此时各个资源管理器就会回滚本地数据库事务，释放资源，并返回结果通知。
<img loading="lazy" src="/wiki/assets/images/2PC3-3a0b827d48c6304ece3170f3f41f653c.webp" width="2202" height="760" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2pc-存在的一些问题">2PC 存在的一些问题<a class="hash-link" href="#2pc-存在的一些问题" title="Direct link to heading">​</a></h3><ul><li>在整个流程中，各个资源管理器节点存在阻塞，只有当所有的节点都准备完成之后，事务管理器才会发出进行全局事务提交的通知，这个过程如果很长，则会有很多节点长时间占用资源，从而影响整个节点的性能。一旦资源管理器挂了，就会出现一直阻塞等待的情况。类似问题，我们可以通过设置事务超时时间来解决。</li><li>仍然存在数据不一致的可能性，例如，在最后通知提交全局事务时，由于网络故障，部分节点有可能收不到通知，由于这部分节点没有提交事务，就会导致数据不一致的情况出现。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3pc">3PC<a class="hash-link" href="#3pc" title="Direct link to heading">​</a></h3><p>3PC 把 2PC 的准备阶段分为了准备阶段和预处理阶段。</p><ul><li>在第一阶段只是询问各个资源节点是否可以执行事务</li><li>在第二阶段，所有的节点反馈可以执行事务，才开始执行事务操作</li><li>最后在第三阶段执行提交或回滚操作。并且在事务管理器和资源管理器中都引入了超时机制，如果在第三阶段，资源节点一直无法收到来自资源管理器的提交或回滚请求，它就会在超时之后，继续提交事务</li></ul><p>3PC 可以通过超时机制，避免管理器挂掉所造成的长时间阻塞问题，但其实这样还是无法解决在最后提交全局事务时，由于网络故障无法通知到一些节点的问题，特别是回滚通知，这样会导致事务等待超时从而默认提交。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3pc相对于2pc而言到底优化了什么地方呢">3PC相对于2PC而言到底优化了什么地方呢<a class="hash-link" href="#3pc相对于2pc而言到底优化了什么地方呢" title="Direct link to heading">​</a></h3><p>相比较2PC而言，3PC对于PM和TM 都设置了超时时间，而2PC只有TM才拥有超时机制。这解决了一个什么问题呢？这个优化点，主要是避免了参与者在长时间无法与TM节点通讯（TM挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="事务补偿机制tcc">事务补偿机制（TCC）<a class="hash-link" href="#事务补偿机制tcc" title="Direct link to heading">​</a></h3><p>TCC 采用最终一致性的方式实现了一种柔性分布式事务，与 XA 规范实现的二阶事务不同的是，TCC 的实现是基于服务层实现的一种二阶事务提交。</p><p>TCC 分为三个阶段，即 Try、Confirm、Cancel 三个阶段。</p><p><img loading="lazy" src="/wiki/assets/images/TCC-0bdc6a5a848837e6c52d7a0e727d55a6.webp" width="1892" height="1300" class="img_ev3q"></p><ul><li>Try 阶段: 主要尝试执行业务，执行各个服务中的 Try 方法，主要包括预留操作</li><li>Confirm 阶段：确认 Try 中的各个方法执行成功，然后通过 TM 调用各个服务的 Confirm 方法，这个阶段是提交阶段；</li><li>Cancel 阶段：当在 Try 阶段发现其中一个 Try 方法失败，例如预留资源失败、代码异常等，则会触发 TM 调用各个服务的 Cancel 方法，对全局事务进行回滚，取消执行业务。</li></ul><p>以上执行只是保证 Try 阶段执行时成功或失败的提交和回滚操作，你肯定会想到，如果在 Confirm 和 Cancel 阶段出现异常情况，那 TCC 该如何处理呢？此时 TCC 会不停地重试调用失败的 Confirm 或 Cancel 方法，直到成功为止。</p><p>TCC 补偿性事务也有比较明显的缺点，那就是对业务的侵入性非常大。</p><p>首先，我们需要在业务设计的时候考虑预留资源；然后，我们需要编写大量业务性代码，例如 Try、Confirm、Cancel 方法；最后，我们还需要为每个方法考虑幂等性。这种事务的实现和维护成本非常高，但综合来看，这种实现是目前大家最常用的分布式事务解决方案。</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#xa-规范" class="table-of-contents__link toc-highlight">XA 规范</a><ul><li><a href="#2pc" class="table-of-contents__link toc-highlight">2PC</a></li><li><a href="#2pc-存在的一些问题" class="table-of-contents__link toc-highlight">2PC 存在的一些问题</a></li><li><a href="#3pc" class="table-of-contents__link toc-highlight">3PC</a></li><li><a href="#3pc相对于2pc而言到底优化了什么地方呢" class="table-of-contents__link toc-highlight">3PC相对于2PC而言到底优化了什么地方呢</a></li><li><a href="#事务补偿机制tcc" class="table-of-contents__link toc-highlight">事务补偿机制（TCC）</a></li></ul></li></ul></div></div></div></div></main></div></div></div>
<script src="/wiki/assets/js/runtime~main.4af80907.js"></script>
<script src="/wiki/assets/js/main.6f5d8ae1.js"></script>
</body>
</html>