<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-bigdata/hbase/hbase-architecture">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.1">
<link rel="alternate" type="application/rss+xml" href="/wiki/blog/rss.xml" title="Dev Wiki RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/wiki/blog/atom.xml" title="Dev Wiki Atom Feed">




<link rel="stylesheet" href="/wiki/katex/katex.min.css"><title data-rh="true">深入理解HBase架构 | Dev Wiki</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="http://souo.github.io/wiki/docs/bigdata/hbase/hbase-architecture"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="深入理解HBase架构 | Dev Wiki"><meta data-rh="true" name="description" content="HBase 具有以下优点："><meta data-rh="true" property="og:description" content="HBase 具有以下优点："><link data-rh="true" rel="canonical" href="http://souo.github.io/wiki/docs/bigdata/hbase/hbase-architecture"><link data-rh="true" rel="alternate" href="http://souo.github.io/wiki/docs/bigdata/hbase/hbase-architecture" hreflang="en"><link data-rh="true" rel="alternate" href="http://souo.github.io/wiki/docs/bigdata/hbase/hbase-architecture" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://undefined-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/wiki/assets/css/styles.a6de386b.css">
<link rel="preload" href="/wiki/assets/js/runtime~main.4af80907.js" as="script">
<link rel="preload" href="/wiki/assets/js/main.6f5d8ae1.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/wiki/"><b class="navbar__title text--truncate">知识库</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/wiki/get-started">Get Started</a><a class="navbar__item navbar__link" href="/wiki/docs/welcome">Docs</a><a class="navbar__item navbar__link" href="/wiki/blog">Blog</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">WIKI</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/wiki/docs/java/jvm/jvm-architecture">Java</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/wiki/docs/bigdata/hbase/hbase-architecture">BigData</a></li><li><a class="dropdown__link" href="/wiki/docs/math/quick-power">math</a></li><li><a class="dropdown__link" href="/wiki/docs/db/profiling/sql">数据库</a></li><li><a class="dropdown__link" href="/wiki/docs/questions/java/class_file">面试题</a></li></ul></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/wiki/docs/welcome">Getting Started</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/wiki/docs/java/jvm/jvm-architecture">JAVA</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/wiki/docs/db/profiling/sql">DB</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/wiki/docs/bigdata/hbase/hbase-architecture">BIGDATA</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/wiki/docs/bigdata/hbase/hbase-architecture">Hbase</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/wiki/docs/bigdata/hbase/hbase-architecture">深入理解HBase架构</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/wiki/docs/bigdata/hadoop/hadoop-tuning">Hadoop</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/wiki/docs/bigdata/spark/turning_spark">Spark</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/wiki/docs/bigdata/raft">一致性算法</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/wiki/docs/math/quick-power">MATH</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/wiki/docs/momd/momd-1">MOMD</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/wiki/docs/NLP/supervised-ml-sentiment-analysis">NLP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/wiki/docs/git/git-pathspece">GIT</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/wiki/docs/programming/regex">PROGRAMMING</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/wiki/docs/questions/java/class_file">INTERVIEWS</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/wiki/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">BIGDATA</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Hbase</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">深入理解HBase架构</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Apache HBase 架构的好处</h1><p>HBase 具有以下优点：</p><ul><li>强一致性模型<ul><li>当写入返回时，所有读者都会看到相同的值</li></ul></li><li>自动缩放<ul><li>数据增长过大时 Region 分裂</li><li>使用 HDFS 传播和复制数据</li></ul></li><li>内置恢复<ul><li>使用 Write Ahead Log（类似于文件系统上的日记功能）</li></ul></li><li>与 Hadoop 集成<ul><li>HBase 上的 MapReduce 非常简单</li></ul></li></ul><h1>HBase 架构组成</h1><p>HBase 采用 Master/Slave 架构, 由 Region servers、Master、Zookeeeper 三个组建构成。</p><p>Region servers 为读取和写入提供数据。 访问数据时，客户端直接与 HBase RegionServers 通信。
HBase Master 负责 region 分配，DDL（创建，删除表）操作。
Zookeeper 是 HDFS 的一部分，负责实时维护集群状态。</p><p>Hadoop DataNode 存储 Region Server 管理的数据。 所有 HBase 数据都存储在 HDFS 文件中。 Region servers 与 HDFS DataNode 共同工作，后者支持 RegionServers 服务的数据本地性（将数据放在需要的位置附近）。 HBase 数据在写入时是本地数据，但是当移动某个 region 时，它在 compaction.之前不是本地的。</p><p>NameNode 维护组成文件的所有物理数据块的元数据信息。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig1-13163402febac7942b4f6da64ba0247b.png" width="632" height="343" class="img_ev3q"></p><h1>Regions</h1><p>HBase 表按 row key 水平分为&quot;region&quot;。&quot;region&quot;包含表中从 region 的开始键和结束键之间的的所有行。 region 被分配给集群中的节点，称为“Region Server”，它们为读取和写入提供数据。 egion Server 可以服务大约 1,000 个 region。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig2-7f724f8e977a9771043d42448fbe98d1.png" width="724" height="337" class="img_ev3q"></p><h1>HBase HMaster</h1><p>Master 负责：</p><p>协调 Region server</p><ul><li>在启动时分配 Region，重新分配 Region 以进行恢复或负载平衡</li><li>监控集群中的所有 RegionServer 实例（侦听来自 zookeeper 的通知）</li></ul><p>管理功能</p><ul><li>用于创建，删除，更新表的接口</li></ul><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig3-70369082156473f77859312e431e2125.png" width="722" height="367" class="img_ev3q"></p><h1>zookeeper: 协调者</h1><p>HBase 使用 ZooKeeper 作为分布式协调服务来维护集群中的服务器状态。Zookeeper 维护哪些服务器处于活动状态且可用，并提供服务器故障通知。 Zookeeper 使用共识来保证共同的共享状态。 请注意，应该有三到五台机器达成共识。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig4-5076ead98f45597928ff3d61151004a8.png" width="703" height="318" class="img_ev3q"></p><h1>这些组件如何一起工作</h1><p>Zookeeper 用于协调分布式系统组件的共享状态信息。 Region Server 和活动 HMaster 连接到 ZooKeeper 的会话。 ZooKeeper 通过心跳维护活动会话。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig5-b0b77481aa8ad7b9896c732160262784.png" width="722" height="329" class="img_ev3q"></p><p>每个 Region Server 都会创建一个 ephemeral 节点。 HMaster 监视这些节点以发现可用的 Region Server，
并且还监视这些节点为了故障发现。</p><p>HMasters 争相创建一个 ephemeral 的节点。 Zookeeper 确定第一个并使用它来确保只有一个主服务器处于活动状态。 活动 HMaster 将心跳发送到 Zookeeper，非活动 HMaster 监听活动 HMaster 故障的通知。</p><p>如果 Region Server 或活动 HMaster 未能发送心跳，则会话过期并删除相应的 ephemeral 节点。 将通知已删除节点的更新侦听器。 活动 HMaster 侦听 Region Server，并在失败时恢复 Region Server。 非活动 HMaster 监听活动 HMaster 故障，如果活动 HMaster 失败，则非活动 HMaster 变为活动状态。</p><h1>HBase 的第一次读写</h1><p>有一个名为 hbase:meta 表的特殊 HBase Catalog 表，它保存集群中区域的位置。 ZooKeeper 存储 hbase:meta 表的位置。</p><p>hbase:meta 表的结构如下：</p><p>key: (<!-- -->[table]<!-- -->,<!-- -->[region start key]<!-- -->,<!-- -->[region id]<!-- -->)</p><p>value:</p><ul><li>info:regioninfo (region 的序列化 HRegionInfo 实例)</li><li>info:server (服务器：包含此 region 的 RegionServer 的端口)</li><li>info:serverstartcode 包含此 region 的 RegionServer 进程的开始时间)</li></ul><p>当表处于 split 过程中时，将创建另外两列，称为 info：splitA 和 info：splitB。 这些列代表两个子 region。 这些列的值也是序列化的 HRegionInfo 实例。 region split 后，最终将删除此行。</p><p>这是 client 第一次读取或写入 HBase 时发生的情况：</p><ul><li><p>客户端从 ZooKeeper 获取 hbase:meta 表所在的 Region serve。</p></li><li><p>客户端根据 table 和 rowkey 查询 hbase:meta 表获取对应的 Region server。 客户端将此信息与 hbase:meta 表位置一起缓存。</p></li><li><p>从相应的 Region Server 获取 Row。</p></li></ul><p>之后的读取，客户端使用缓存来检索 hbase:meta 位置和先前读取的行键。 随着时间的推移，它不需要查询 hbase:meta 表，除非由于 region 已移动而导致未命中; 然后它将重新查询和更新缓存。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig6-da85ba359e878cb1d15dd70689cd9485.png" width="590" height="356" class="img_ev3q">)</p><h1>Region Server 组件</h1><p>Region Serve 在 HDFSDataNode 上运行，并具有以下组件：</p><ul><li>WAL：Write Ahead Log 是分布式文件系统上的文件。 WAL 用于存储尚未持久存储到永久存储的新数据; 它用于在发生故障时进行恢复。</li><li>BlockCache：是读缓存。 它将频繁读取的数据存储在内存中。 LRU 缓存策略。</li><li>MemStore：是写缓存。 它存储尚未写入磁盘的新数据。 在写入磁盘之前对其进行排序。 每个 region 每个列族有一个 MemStore。</li><li>Hfiles：将 row 存储为磁盘上的排序 KeyValues。</li></ul><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig8-c2ae045ff8f08c9fa260948c28ccdf32.png" width="675" height="366" class="img_ev3q"></p><h1>hbase 写步骤</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤一">步骤一<a class="hash-link" href="#步骤一" title="Direct link to heading">​</a></h2><p>当客户端发出 Put 请求时，第一步是将数据写入预写日志 WAL：</p><ul><li>更改追加到到存储在磁盘上的 WAL 文件的末尾。</li><li>WAL 用于在服务器崩溃时恢复尚未保留的数据。</li></ul><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig9-8abac7bf9ccc7395d068eae76b9c993a.png" width="716" height="363" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="步骤二">步骤二<a class="hash-link" href="#步骤二" title="Direct link to heading">​</a></h2><p>一旦将数据写入 WAL 后，将其放入 MemStore 中。然后，返回给客户端 put 请求确认。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig10-560c39000ea012db4c64ee2718d24705.png" width="664" height="298" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="memstore">MemStore<a class="hash-link" href="#memstore" title="Direct link to heading">​</a></h2><p>MemStore 将更新作为已排序的 KeyValues 存储在内存中，与将存储在 HFile 中的保持相同。 每个 CF（column family）有一个 MemStore。 更新按照 CF 排序。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig11-f613bc772b24ecb355b8c1f4f9f93571.png" width="719" height="351" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="region-flush">Region Flush<a class="hash-link" href="#region-flush" title="Direct link to heading">​</a></h2><p>当 MemStore 累积足够的数据时，整个有序集合将被写入 HDFS 中的新 HFile 中。</p><p>HBase 每个 CF 使用多个 HFile，其中包含实际的单元格或 KeyValue 实例。 这些文件随着时间的推移而创建，因为在 MemStores 中排序的 KeyValue 将作为文件刷新到磁盘。</p><p>请注意，这是 HBase 中列族数限制的一个原因。 每个 CF 有一个 MemStore; 当其中一个满员时，他们都会 flush。</p><p>它还保存了最后写入的序列号，以便系统知道到目前为止持久化的内容。最高序列号存储为每个 HFile 中的元字段，以反映持久化已结束的位置和继续的位置。 在 region 启动时，读取序列号，并将最高值用作新编辑的序列号。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig12-8fa9e738fede5bf79040211484e6f520.png" width="622" height="248" class="img_ev3q"></p><p>HFile
description:
published: true
date: 2021-01-15T08:33:57.512Z
tags:
editor: undefined
dateCreated: 2021-01-15T08:21:32.834Z</p><hr><h1>Hfile</h1><p>数据存储在 HFile 中，其中包含已排序的键/值。 当 MemStore 累积足够的数据时，整个已排序的 KeyValue 集将写入 HDFS 中的新 HFile。 这是一个顺序写。 它非常快，因为它避免了磁盘驱动器头的移动。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig13-bf4eacb3b3ffd5d791419771cd424d48.png" width="698" height="351" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="hfile-结构">HFile 结构<a class="hash-link" href="#hfile-结构" title="Direct link to heading">​</a></h2><p>Hfile 的存储格式详情<a href="https://hbase.apache.org/book.html#_hfile_format_2" target="_blank" rel="noopener noreferrer">点这里查看</a></p><p>HFile 包含一个多层索引，允许 HBase 在不必读取整个文件的情况下查找数据。 多级索引就像一个 b+树：</p><ul><li>键值对按递增顺序存储</li><li>在 64KB“块”中的索引通过 rowkey 指向键值对数据</li><li>每个块都有自己的叶索引</li><li>每个块的最后一个键放在中间索引中</li><li>根索引指向中间索引</li></ul><p>Trailer 有指向 meta 块的指针。它是在持久化数据到文件结束时写入的，Trailer 还包含布隆过滤器和时间范围信息等信息。 Bloom 过滤器有助于跳过不包含某个行键的文件。 如果文件不在读取的时间范围内，则时间范围信息对于跳过文件很有用。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig14-e4a9a775187cb83f4a4d5e6086427478.png" width="688" height="349" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="hfile-index">HFile Index<a class="hash-link" href="#hfile-index" title="Direct link to heading">​</a></h2><p>在 Hfile 被打开时索引被加载到内存</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig15-f2dce0b0c999c5bdd968fbc55cbf1cb0.png" width="772" height="341" class="img_ev3q"></p><h1>hbase 读合并</h1><p>我们已经看到一行的 KeyValue 单元格可以在多个位置，已经持久化的行单元在 Hfiles 中，最近更新的单元在 MemStore 中，并且最近读取的单元在 block cache 中。</p><p>所以当你读一行时，系统如何获得相应的单元格返回？ Read 通过以下步骤合并 block cache，MemStore 和 HFiles 中的键值：</p><ul><li>首先，scanner 在 Block cache 中查找行单元格 - 读缓存, 最近读取键值在此处缓存，并且在需要内存时将最近最少使用的值清除。</li><li>接下来，scanner 在 memStore 中查找，内存中的写入缓存包含最近写入的单元格。</li><li>如果 scanner 没有找到 MemStore 和 Block Cache 中的所有行单元格，那么 HBase 将使用 Block Cache 索引和 bloom 过滤器将 HFiles 加载到内存中，该内存可能包含目标行单元格</li></ul><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig16-4d3d6e7645e822aaab0fb13de3641d18.png" width="769" height="278" class="img_ev3q"></p><p>如前所述，每个 MemStore 可能有许多 HFile，这意味着对于读取，可能必须检查多个文件，这可能会影响性能。 这称为读放大（read amplification）。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig17-94b8bb389d581d230d96080c183a0051.png" width="596" height="307" class="img_ev3q"></p><h1>Minor &amp; Major Compaction</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="minor-compaction">Minor Compaction<a class="hash-link" href="#minor-compaction" title="Direct link to heading">​</a></h2><p>HBase 将自动选择一些较小的 HFile 并将其重写为更少的更大的 Hfiles。 此过程称为 Minor Compaction。Minor Compaction 通过将较小的文件重写为较少但较大的文件来执行合并排序，从而减少了存储文件的数量。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig18-d731a340c1e3f3d4e8ee57ee30b60b1b.png" width="723" height="329" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="major-compaction">Major Compaction<a class="hash-link" href="#major-compaction" title="Direct link to heading">​</a></h2><p>Major Compaction 将 Region 中的所有 HFile 合并并重写为每 CF 一个 HFile，并在此过程中删除已删除或已过期的单元格。 这提高了读取性能;</p><p>但是，由于 Major Compaction 重写所有文件，因此在此过程中可能会发生大量磁盘 I / O 和网络流量。 这称为写入放大。</p><p>由于写入放大，Major Compaction 通常安排在周末或晚上运行。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig19-911939a05247d1758ebc752979f89bad.png" width="653" height="339" class="img_ev3q"></p><h1>Region 等于连续的 key</h1><p>让我们快速回顾一下 region：</p><ul><li>表可以水平划分为一个或多个 region。 region 包含开始键和结束键之间的连续排序行范围</li><li>每个区域的大小为 1GB（默认,可以设置）</li><li>TableServer 的一个 region 由 RegionServer 提供给客户端</li><li>RegionServer 可以服务大约 1,000 个 region（可能属于同一个表或不同的表）</li></ul><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig20-b16f794aa867ee10e9cc653139b4f172.png" width="653" height="334" class="img_ev3q"></p><h1>Region Split</h1><p>最初每个表有一个 region。 当一个 region 变得太大时，它会分裂成两个子 region。 两个子 region（代表原始 region 的一半）在同一个 Region server 上并行打开，然后将 split 报告给 HMaster。 出于负载平衡的原因，HMaster 可以安排将新 region 移到其他服务器。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig21-05d95a19f7cd7befdabad07fa3fb3543.png" width="675" height="361" class="img_ev3q"></p><h1>读负载平衡</h1><p>split 最初发生在同一个 Region Server 上，但出于负载平衡的原因，HMaster 可能会安排将新 Region 移到其他服务器上。</p><p>这导致新的 Region server 从远程 HDFS 节点提供数据，直到 major compaction 将数据文件移动到 Region Server 的本地节点。 HBase 数据在写入时是本地数据，但是当移动某个 region（用于负载平衡或恢复）时，它在 major compaction 之前不是本地的。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig22-b78560c1b66c47fad8dd50a43d8764c2.png" width="714" height="358" class="img_ev3q"></p><h1>HDFS Data Replication</h1><p>所有写入和读取都是来自主节点。 HDFS 复制 WAL 和 HFile 块。 HFile 块复制自动发生。 HBase 依赖 HDFS 在存储文件时提供数据安全性。 在 HDFS 中写入数据时，本地写入一个副本，然后将其复制到第二个节点，将第三个副本写入第三个节点。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig23-e174118ce3ee63fd878b52c5ae2985d1.png" width="641" height="302" class="img_ev3q"></p><p>WAL 文件和 Hfiles 会持久保存在磁盘上并进行复制，那么 HBase 如何恢复未持久保存到 HFiles 中的 MemStore 更新呢？</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig24-a297014c153da6c99a19e298732cd145.png" width="679" height="349" class="img_ev3q"></p><h1>HBase 崩溃恢复</h1><p>当 RegionServer 发生故障时，崩溃 Region 将不可用，直到检测和恢复步骤发生。</p><p>当 Zookeeper 失去 RegionServer 心跳时，它将确定节点失败。 然后，HMaster 将被通知 Region Server 已失败。</p><p>当 HMaster 检测到 RegionServer 已崩溃时，HMaster 会将崩溃的 RegionServer 中的 Region 重新分配给活动的 Region server。</p><p>为了恢复未刷新到磁盘的崩溃 Region server 的 memstore 更新。 HMaster 将属于崩溃 Region server 的 WAL 拆分为单独的文件，并将这些文件存储在新的 Region Server 的数据节点中。 然后，每个 Region Server 从相应的拆分 WAL 重放 WAL，以重建该 region 的 memstore。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig25-e85c62c3578020360aa4fa96f675c833.png" width="708" height="368" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="数据恢复">数据恢复<a class="hash-link" href="#数据恢复" title="Direct link to heading">​</a></h2><p>WAL 文件包含编辑列表，其中一个编辑表示单个 put 或 delete。 编辑按时间顺序编写，因此，对于持久性，添加内容会附加到存储在磁盘上的 WAL 文件的末尾。</p><p>如果数据仍然在内存中并且没有持久保存到 HFile 时会发生什么？ WAL 被重播。 通过读取 WAL，将包含的编辑添加并排序到当前的 MemStore 来重放 WAL。 最后，MemStore 刷新以写入对 HFile 的更改。</p><p><img loading="lazy" src="/wiki/assets/images/HBaseArchitecture-Blog-Fig26-e6ef17bbf348dd967c66efff766608d2.png" width="724" height="378" class="img_ev3q"></p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/wiki/docs/db/profiling/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">索引的失效与优化</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/wiki/docs/bigdata/hadoop/hadoop-tuning"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">hadoop 性能优化</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#步骤一" class="table-of-contents__link toc-highlight">步骤一</a></li><li><a href="#步骤二" class="table-of-contents__link toc-highlight">步骤二</a></li><li><a href="#memstore" class="table-of-contents__link toc-highlight">MemStore</a></li><li><a href="#region-flush" class="table-of-contents__link toc-highlight">Region Flush</a></li><li><a href="#hfile-结构" class="table-of-contents__link toc-highlight">HFile 结构</a></li><li><a href="#hfile-index" class="table-of-contents__link toc-highlight">HFile Index</a></li><li><a href="#minor-compaction" class="table-of-contents__link toc-highlight">Minor Compaction</a></li><li><a href="#major-compaction" class="table-of-contents__link toc-highlight">Major Compaction</a></li><li><a href="#数据恢复" class="table-of-contents__link toc-highlight">数据恢复</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/wiki/assets/js/runtime~main.4af80907.js"></script>
<script src="/wiki/assets/js/main.6f5d8ae1.js"></script>
</body>
</html>